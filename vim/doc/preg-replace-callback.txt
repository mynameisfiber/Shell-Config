*preg_replace_callback* -- Perform a regular expression search and replace using
a callback

  mixed preg_replace_callback(mixed pattern, callback callback, mixed subject [, int limit [, int count]])~

The behavior of this function is almost identical to |preg_replace|, except
for the fact that instead of {replacement} parameter, one should specify a
{callback}.

{pattern} The pattern to search for. It can be either a string or an array
with strings.

{callback} A callback that will be called and passed an array of matched
elements in the {subject} string. The callback should return the replacement
string.

You'll often need the {callback} function for a |preg_replace_callback| in
just one place. In this case you can use an anonymous function (since PHP
5.3.0) or |create_function| to declare an anonymous function as callback
within the call to |preg_replace_callback|. By doing it this way you have all
information for the call in one place and do not clutter the function
namespace with a callback function's name not used anywhere else.

|preg_replace_callback| and |create_function|

<?php >
  /* a unix-style command line filter to convert uppercase
   * letters at the beginning of paragraphs to lowercase */
  $fp = fopen("php://stdin", "r") or die("can't read stdin");
  while (!feof($fp)) {
      $line = fgets($fp);
      $line = preg_replace_callback(
          '|<p>\s*\w|',
          create_function(
              // single quotes are essential here,
              // or alternative escape all $ as \$
              '$matches',
              'return strtolower($matches[0]);'
          ),
          $line
      );
      echo $line;
  }
  fclose($fp);
?>





{subject} The string or an array with strings to search and replace.

{limit} The maximum possible replacements for each pattern in each {subject}
string. Defaults to -1 (no limit).

{count} If specified, this variable will be filled with the number of
replacements done.

|preg_replace_callback| returns an array if the {subject} parameter is an
array, or a string otherwise. On errors the return value is NULL

If matches are found, the new subject will be returned, otherwise {subject}
will be returned unchanged.

Version Description 5.1.0 The {count} parameter was added

|preg_replace_callback| example

<?php >
  // this text was used in 2002
  // we want to get this up to date for 2003
  $text = "April fools day is 04/01/2002\n";
  $text.= "Last christmas was 12/24/2001\n";
  // the callback function
  function next_year($matches)
  {
    // as usual: $matches[0] is the complete match
    // $matches[1] the match for the first subpattern
    // enclosed in '(...)' and so on
    return $matches[1].($matches[2]+1);
  }
  echo preg_replace_callback(
              "|(\d{2}/\d{2}/)(\d{4})|",
              "next_year",
              $text);
?>

The above example will output:

  April fools day is 04/01/2003
  Last christmas was 12/24/2002



|preg_replace_callback| using recursive structure to handle encapsulated BB
code

<?php >
  $input = "plain [indent] deep [indent] deeper [/indent] deep [/indent] plain";
  
  function parseTagsRecursive($input)
  {
  
      $regex = '#\[indent]((?:[^[]|\[(?!/?indent])|(?R))+)\[/indent]#';
  
      if (is_array($input)) {
          $input = '<div style="margin-left: 10px">'.$input[1].'</div>';
      }
  
      return preg_replace_callback($regex, 'parseTagsRecursive', $input);
  }
  
  $output = parseTagsRecursive($input);
  
  echo $output;
?>





PCRE Patterns |preg_replace| |preg_last_error| |create_function| Anonymous
functions information about the callback type

vim:ft=help:
