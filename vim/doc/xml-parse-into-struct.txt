*xml_parse_into_struct* -- Parse XML data into an array structure

  int xml_parse_into_struct(resource parser, string data, array values [, array index])~

This function parses an XML string into 2 parallel array structures, one
({index}) containing pointers to the location of the appropriate values in the
{values} array. These last two parameters must be passed by reference.

{parser} A reference to the XML parser.

{data} A string containing the XML data.

{values} An array containing the values of the XML data

{index} An array containing pointers to the location of the appropriate values
in the $values.

|xml_parse_into_struct| returns 0 for failure and 1 for success. This is not
the same as FALSE and TRUE, be careful with operators such as ===.

Below is an example that illustrates the internal structure of the arrays
being generated by the function. We use a simple note tag embedded inside a
para tag, and then we parse this and print out the structures generated:
|xml_parse_into_struct| example

<?php >
  $simple = "<para><note>simple note</note></para>";
  $p = xml_parser_create();
  xml_parse_into_struct($p, $simple, $vals, $index);
  xml_parser_free($p);
  echo "Index array\n";
  print_r($index);
  echo "\nVals array\n";
  print_r($vals);
?>

When we run that code, the output will be:

  Index array
  Array
  (
      [PARA] => Array
          (
              [0] => 0
              [1] => 2
          )
  
      [NOTE] => Array
          (
              [0] => 1
          )
  
  )
  
  Vals array
  Array
  (
      [0] => Array
          (
              [tag] => PARA
              [type] => open
              [level] => 1
          )
  
      [1] => Array
          (
              [tag] => NOTE
              [type] => complete
              [level] => 2
              [value] => simple note
          )
  
      [2] => Array
          (
              [tag] => PARA
              [type] => close
              [level] => 1
          )
  
  )



Event-driven parsing (based on the expat library) can get complicated when you
have an XML document that is complex. This function does not produce a DOM
style object, but it generates structures amenable of being transversed in a
tree fashion. Thus, we can create objects representing the data in the XML
file easily. Let's consider the following XML file representing a small
database of aminoacids information: moldb.xml - small database of molecular
information

  <?xml version="1.0"?>
  <moldb>
  
    <molecule>
        <name>Alanine</name>
        <symbol>ala</symbol>
        <code>A</code>
        <type>hydrophobic</type>
    </molecule>
  
    <molecule>
        <name>Lysine</name>
        <symbol>lys</symbol>
        <code>K</code>
        <type>charged</type>
    </molecule>
  
  </moldb>



And some code to parse the document and generate the appropriate objects:
parsemoldb.php - parses moldb.xml into an array of molecular objects

<?php >
  class AminoAcid {
      var $name;  // aa name
      var $symbol;    // three letter symbol
      var $code;  // one letter code
      var $type;  // hydrophobic, charged or neutral
      
      function AminoAcid ($aa) 
      {
          foreach ($aa as $k=>$v)
              $this->$k = $aa[$k];
      }
  }
  
  function readDatabase($filename) 
  {
      // read the XML database of aminoacids
      $data = implode("", file($filename));
      $parser = xml_parser_create();
      xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);
      xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
      xml_parse_into_struct($parser, $data, $values, $tags);
      xml_parser_free($parser);
  
      // loop through the structures
      foreach ($tags as $key=>$val) {
          if ($key == "molecule") {
              $molranges = $val;
              // each contiguous pair of array entries are the 
              // lower and upper range for each molecule definition
              for ($i=0; $i < count($molranges); $i+=2) {
                  $offset = $molranges[$i] + 1;
                  $len = $molranges[$i + 1] - $offset;
                  $tdb[] = parseMol(array_slice($values, $offset, $len));
              }
          } else {
              continue;
          }
      }
      return $tdb;
  }
  
  function parseMol($mvalues) 
  {
      for ($i=0; $i < count($mvalues); $i++) {
          $mol[$mvalues[$i]["tag"]] = $mvalues[$i]["value"];
      }
      return new AminoAcid($mol);
  }
  
  $db = readDatabase("moldb.xml");
  echo "** Database of AminoAcid objects:\n";
  print_r($db);
?>



After executing parsemoldb.php, the variable $db contains an array of
AminoAcid objects, and the output of the script confirms that:

  ** Database of AminoAcid objects:
  Array
  (
      [0] => aminoacid Object
          (
              [name] => Alanine
              [symbol] => ala
              [code] => A
              [type] => hydrophobic
          )
  
      [1] => aminoacid Object
          (
              [name] => Lysine
              [symbol] => lys
              [code] => K
              [type] => charged
          )
  
  )

vim:ft=help:
